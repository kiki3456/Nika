<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Nika The Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    html, body {
      height: 100%;
      width: 100%;
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
      overflow: hidden;
      touch-action: manipulation;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    h1, #score {
      color: #ff66a3;
      text-align: center;
      margin: 5px 0;
      text-shadow: 0 0 10px rgba(255, 102, 163, 0.7);
    }
    
    #gameContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex: 1;
      width: 100%;
      max-width: 100vw;
      padding: 0 5px;
    }
    
    .title {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 10px;
      position: relative;
    }
    
    .bow {
      font-size: 28px;
      margin-right: 10px;
      animation: bounce 2s infinite;
    }
    
    .canvas-wrapper {
      position: relative;
      width: 100%;
      max-width: 240px;
      margin: 0 auto;
    }
    
    canvas {
      display: block;
      width: 100%;
      height: auto;
      aspect-ratio: 240/400;
      border: 2px solid #ff66a3;
      border-radius: 5px;
      box-shadow: 0 0 15px rgba(255, 102, 163, 0.5);
      image-rendering: pixelated;
    }
    
    #score {
      font-size: 20px;
      font-weight: bold;
      margin: 10px 0;
      background: rgba(0, 0, 0, 0.5);
      padding: 8px 15px;
      border-radius: 20px;
      border: 1px solid #ff66a3;
    }
    
    .controls {
      display: none;
      flex-direction: column;
      align-items: center;
      margin-top: 10px;
      gap: 5px;
      width: 100%;
      max-width: 240px;
    }
    
    .row {
      display: flex;
      gap: 10px;
      justify-content: center;
      width: 100%;
    }
    
    button {
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid #ff66a3;
      color: #ff66a3;
      font-size: 22px;
      padding: 12px;
      border-radius: 10px;
      min-width: 70px;
      min-height: 55px;
      touch-action: manipulation;
      flex: 1;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 0 10px rgba(255, 102, 163, 0.3);
    }
    
    button:active {
      background: #ff66a3;
      color: black;
      transform: scale(0.95);
    }
    
    #startScreen {
      position: absolute;
      top: 0; 
      left: 0;
      width: 100%; 
      height: 100%;
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
      color: #ff66a3;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10;
      text-align: center;
      padding: 20px;
    }
    
    .start-title {
      font-size: 42px;
      margin-bottom: 20px;
      text-shadow: 0 0 15px rgba(255, 102, 163, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .start-bow {
      font-size: 40px;
      margin-right: 15px;
      animation: spin 3s infinite linear;
    }
    
    #startScreen button {
      font-size: 24px;
      padding: 15px 30px;
      margin-top: 20px;
      background: rgba(255, 102, 163, 0.2);
      border: 2px solid #ff66a3;
      border-radius: 30px;
      color: #fff;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 0 20px rgba(255, 102, 163, 0.5);
    }
    
    #startScreen button:hover {
      background: rgba(255, 102, 163, 0.8);
      transform: scale(1.05);
    }
    
    .particle {
      position: absolute;
      background: #ff66a3;
      border-radius: 50%;
      pointer-events: none;
      opacity: 0.8;
    }
    
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes explode {
      0% { 
        transform: scale(1);
        opacity: 1;
      }
      100% { 
        transform: scale(2);
        opacity: 0;
      }
    }
    
    @media (max-height: 700px) {
      h1, #score {
        font-size: 16px;
      }
      .canvas-wrapper {
        max-width: 200px;
      }
    }
    
    @media (max-width: 480px) {
      button {
        min-width: 60px;
        min-height: 50px;
        font-size: 18px;
        padding: 10px;
      }
      
      .start-title {
        font-size: 32px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <div class="title">
      <div class="bow">🎀</div>
      <h1>Nika The Game</h1>
    </div>
    <div class="canvas-wrapper">
      <canvas id="tetris" width="240" height="400"></canvas>
    </div>
    <div id="score">Score: 0</div>
    <div id="level">Level: 1</div>
    <div id="lines">Lines: 0</div>
    <div class="controls" id="controls">
      <div class="row">
        <button onclick="playerMove(-1)">◀</button>
        <button id="downBtn">▼</button>
        <button onclick="playerMove(1)">▶</button>
      </div>
      <div class="row">
        <button onclick="playerRotate(-1)">↺</button>
        <button onclick="playerRotate(1)">↻</button>
      </div>
    </div>
  </div>

  <!-- Música em loop -->
  <audio id="bgm" src="https://github.com/kiki3456/Nika/raw/7210152aa48e1e0d44da98d717be64b8cbcb7680/Be%20My%20Baby%20%5B8%20Bit%20Tribute%20to%20Ronnie%20Spector%20_%20The%20Ronettes%5D%20-%208%20Bit%20Universe(MP3_160K).mp3" loop></audio>

  <div id="startScreen">
    <div class="start-title">
      <div class="start-bow">🎀</div>
      <h2>Nika The Game</h2>
    </div>
    <p>Complete linhas para ganhar pontos!</p>
    <p>Use as setas para mover e rotacionar as peças</p>
    <button onclick="startGame()">Iniciar Jogo</button>
  </div>

  <script>
    const canvas = document.getElementById('tetris');
    const context = canvas.getContext('2d');
    
    // Sistema de partículas para animação
    const particles = [];
    
    // Arena fixa 12x20
    const arena = createMatrix(12, 20);
    const player = { 
      pos: {x:0, y:0}, 
      matrix: null, 
      score: 0,
      level: 1,
      lines: 0
    };

    function createMatrix(w, h) {
      const matrix = [];
      while (h--) matrix.push(new Array(w).fill(0));
      return matrix;
    }

    function createPiece(type) {
      if (type === 'T') return [[0,0,0],[1,1,1],[0,1,0]];
      if (type === 'O') return [[2,2],[2,2]];
      if (type === 'L') return [[0,3,0],[0,3,0],[0,3,3]];
      if (type === 'J') return [[0,4,0],[0,4,0],[4,4,0]];
      if (type === 'I') return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
      if (type === 'S') return [[0,6,6],[6,6,0],[0,0,0]];
      if (type === 'Z') return [[7,7,0],[0,7,7],[0,0,0]];
    }

    function collide(arena, player) {
      const m = player.matrix, o = player.pos;
      for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
          if (m[y][x] !== 0 &&
              (arena[y + o.y] && arena[y + o.y][x + o.x]) !== 0) {
            return true;
          }
        }
      }
      return false;
    }

    function drawMatrix(matrix, offset) {
      // Ajustar para o tamanho atual do canvas
      const cellSize = Math.min(canvas.width / 12, canvas.height / 20);
      
      matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            context.fillStyle = colors[value];
            context.fillRect(
              (x + offset.x) * cellSize, 
              (y + offset.y) * cellSize, 
              cellSize, 
              cellSize
            );
            
            // Adicionar efeito de brilho
            context.strokeStyle = 'rgba(255,255,255,0.2)';
            context.lineWidth = 1;
            context.strokeRect(
              (x + offset.x) * cellSize, 
              (y + offset.y) * cellSize, 
              cellSize, 
              cellSize
            );
          }
        });
      });
    }

    function draw() {
      // Limpar canvas considerando o tamanho atual
      context.clearRect(0, 0, canvas.width, canvas.height);
      context.fillStyle = '#000';
      context.fillRect(0, 0, canvas.width, canvas.height);
      
      // Desenhar a arena e o jogador
      drawMatrix(arena, {x:0, y:0});
      drawMatrix(player.matrix, player.pos);
      
      // Desenhar partículas
      drawParticles();
    }

    function drawParticles() {
      const cellSize = Math.min(canvas.width / 12, canvas.height / 20);
      
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        context.fillStyle = p.color;
        context.globalAlpha = p.opacity;
        context.fillRect(
          p.x * cellSize, 
          p.y * cellSize, 
          cellSize * p.size, 
          cellSize * p.size
        );
        
        // Atualizar partícula
        p.x += p.vx;
        p.y += p.vy;
        p.opacity -= 0.02;
        p.size -= 0.02;
        
        // Remover partículas que não são mais visíveis
        if (p.opacity <= 0 || p.size <= 0) {
          particles.splice(i, 1);
          i--;
        }
      }
      
      context.globalAlpha = 1;
    }

    function createParticles(x, y, color) {
      for (let i = 0; i < 10; i++) {
        particles.push({
          x: x + Math.random() * 0.8,
          y: y + Math.random() * 0.8,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,
          color: color,
          opacity: 1,
          size: Math.random() * 0.5 + 0.5
        });
      }
    }

    function merge(arena, player) {
      player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            arena[y + player.pos.y][x + player.pos.x] = value;
          }
        });
      });
    }

    function arenaSweep() {
      let rowCount = 0;
      let linesCleared = 0;
      
      for (let y = arena.length - 1; y >= 0; --y) {
        if (arena[y].every(v => v !== 0)) {
          // Criar partículas para animação de explosão
          for (let x = 0; x < arena[y].length; x++) {
            createParticles(x, y, colors[arena[y][x]]);
          }
          
          const row = arena.splice(y, 1)[0].fill(0);
          arena.unshift(row);
          ++y;
          linesCleared++;
          rowCount = linesCleared * 100 * player.level;
        }
      }
      
      if (linesCleared > 0) {
        // Sistema de pontuação melhorado
        const lineScores = [0, 100, 300, 500, 800]; // Pontuação por 0, 1, 2, 3, 4 linhas
        const scoreToAdd = lineScores[linesCleared] * player.level;
        
        player.score += scoreToAdd;
        player.lines += linesCleared;
        
        // Aumentar nível a cada 10 linhas
        player.level = Math.floor(player.lines / 10) + 1;
        
        // Aumentar velocidade com o nível
        dropInterval = Math.max(100, 1000 - (player.level - 1) * 100);
        
        updateStats();
      }
    }

    function playerDrop() {
      player.pos.y++;
      if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        playerReset();
        arenaSweep();
      }
      dropCounter = 0;
    }

    function playerMove(dir) {
      player.pos.x += dir;
      if (collide(arena, player)) player.pos.x -= dir;
    }

    function playerReset() {
      const pieces = 'TJLOSZI';
      player.matrix = createPiece(pieces[Math.floor(pieces.length * Math.random())]);
      player.pos.y = 0;
      player.pos.x = (arena[0].length / 2 | 0) - (player.matrix[0].length / 2 | 0);
      if (collide(arena, player)) {
        arena.forEach(row => row.fill(0));
        player.score = 0;
        player.level = 1;
        player.lines = 0;
        dropInterval = 1000;
        updateStats();
      }
    }

    function playerRotate(dir) {
      const pos = player.pos.x;
      let offset = 1;
      rotate(player.matrix, dir);
      while (collide(arena, player)) {
        player.pos.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.matrix[0].length) {
          rotate(player.matrix, -dir);
          player.pos.x = pos;
          return;
        }
      }
    }

    function rotate(matrix, dir) {
      for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
          [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
      }
      if (dir > 0) matrix.forEach(row => row.reverse());
      else matrix.reverse();
    }

    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;

    function update(time = 0) {
      const deltaTime = time - lastTime;
      lastTime = time;
      dropCounter += deltaTime;
      if (dropCounter > dropInterval) playerDrop();
      draw();
      requestAnimationFrame(update);
    }

    function updateStats() {
      document.getElementById('score').innerText = 'Score: ' + player.score;
      document.getElementById('level').innerText = 'Level: ' + player.level;
      document.getElementById('lines').innerText = 'Lines: ' + player.lines;
    }

    const colors = [
      null,
      '#ff99cc',
      '#ff66a3',
      '#ff4d94',
      '#ff1a75',
      '#d6005f',
      '#ff80bf',
      '#ff3385',
    ];

    document.addEventListener('keydown', event => {
      if (event.key === "ArrowLeft") playerMove(-1);
      else if (event.key === "ArrowRight") playerMove(1);
      else if (event.key === "ArrowDown") playerDrop();
      else if (event.key === "q" || event.key === "Q") playerRotate(-1);
      else if (event.key === "w" || event.key === "W" || event.key === "ArrowUp") playerRotate(1);
    });

    const downBtn = document.getElementById("downBtn");
    let downInterval;
    function startFastDrop() {
      if (!downInterval) downInterval = setInterval(playerDrop, 50);
    }
    function stopFastDrop() {
      clearInterval(downInterval);
      downInterval = null;
    }
    downBtn.addEventListener("mousedown", startFastDrop);
    downBtn.addEventListener("touchstart", startFastDrop);
    downBtn.addEventListener("mouseup", stopFastDrop);
    downBtn.addEventListener("mouseleave", stopFastDrop);
    downBtn.addEventListener("touchend", stopFastDrop);

    function startGame() {
      const bgm = document.getElementById("bgm");
      bgm.play().catch(err => console.log("Áudio bloqueado:", err));
      document.getElementById("startScreen").style.display = "none";
      document.getElementById("controls").style.display = "flex";
      playerReset();
      updateStats();
      update();
    }
    
    // Adicionar elementos de estatísticas ao HTML
    const levelElement = document.createElement('div');
    levelElement.id = 'level';
    levelElement.style.cssText = document.getElementById('score').style.cssText;
    levelElement.innerText = 'Level: 1';
    document.getElementById('gameContainer').insertBefore(levelElement, document.getElementById('score').nextSibling);
    
    const linesElement = document.createElement('div');
    linesElement.id = 'lines';
    linesElement.style.cssText = document.getElementById('score').style.cssText;
    linesElement.innerText = 'Lines: 0';
    document.getElementById('gameContainer').insertBefore(linesElement, levelElement.nextSibling);
  </script>
</body>
</html>
